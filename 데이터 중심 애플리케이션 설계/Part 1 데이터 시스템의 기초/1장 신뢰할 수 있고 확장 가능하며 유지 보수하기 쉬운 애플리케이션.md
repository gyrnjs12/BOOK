# 1장 신뢰할 수 있고 확장 가능하며 유지 보수하기 쉬운 애플리케이션

이번 장에서 알아야 할 내용

신뢰성, 확장성, 유지 보수성의 의미

 오늘날 많은 애플리케이션은 데이터 중심적이다. 이러한 애플리케이션은 CPU 성능 보다는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도를 중요시 생각한다. 

데이터 중심 애플리케이션은 다음과 같은 구성 요소를 필요로 한다.

- 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 (데이터베이스)
- 읽기 속도 향상을 위한 값 비싼 수행 결과를 기억 (캐시)
- 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공 (검색 색인(search index))
- 비동기 처리를 위해 다른 프로세스로 메세지 보내기 (스트림 처리(stream processing))
- 주기적으로 대량의 누적된 데이터를 분석 (일괄 처리(batch processing))

너무 뻔한 말로 들린다면 이는 데이터 시스템이 성공적으로 추상화 됐기 때문이다. 보통 애플리케이션을 만들 때 대부분의 엔지니어는 처음부터 잘 구현된 도구를 가져와 위와 같은 기능을 구현한다.

하지만 현실은 애플리케이션마다 요구사항이 다르기 때문에 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.

이 책에서는 다양한 도구들의 공통된 특성이 무엇이고, 서로 구별되는 특성은 무엇인지 그러한 특성을 어떻게 구현했는지 알아본다.

## 데이터 시스템에 대한 생각

---

 데이터베이스, 캐시, 큐 등은 표면적으로 비슷하더라도(얼마 동안 데이터 저장) 서로 다른 접근 패턴을 가지고 있어 구현 방식이 다르지만 왜 모든 것을 **데이터 시스템** 이라는 포괄적 용어로 묶는 이유는 뭘까?

- 최근에 만들어진 데이터 저장, 처리 도구는 이미 다양한 사용 사례에 최적화돼있어 더 이상 전통적인 분류에 맞지 않는다.
- 많은 애플리케이션들은 단일 도구로는 더 이상 데이터 처리 및 저장을 만족하지 못하는 광범위한 요구 사항을 가지고 있다. 대신 작업은 단일 도구로 효율적으로 수행할 수 있는 태스크로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.

개발자는 서비스 제공을 위해 API를 통해 통신하고 사용자가 일관된 결과를 볼 수 있게끔 캐시를 올바르게 무효화하거나 업데이트하는 등의 특정 보장 기능을 제공할 수 있다.

이런 데이터 시스템이나 서비스를 설계할 때는 이러한 문제가 발생한다.

- 내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지하려면 어떻게 해야 할까?
- 시스템의 일부 성능이 저하되더라도 사용자에 일관되게 좋은 성능을 어떻게 제공할 수 있을까?
- 부하 증가를 다루기 위해 어떻게 규모를 확장할까?
- 서비스를 위해 좋은 API는 어떤 모습일까?

이 책에서는 대부분의 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.

1. 신뢰성(Reliability)

    하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작해야 한다.

2. 확장성(Scalability)

    시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야한다.

3. 유지 보수성(Maintainability)

    시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

## 신뢰성

소프트웨어의 경우 일반적인 기대치는 다음과 같다.

- 애플리케이션은 사용자가 기대한 기능을 수행한다.
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

위의 기대치가 "올바르게 동작함" 을 의미한다면, **신뢰성이란 "무언가 잘못되더라도 지속적으로 올바르게 동작함" 으로 이해할 수 있다.**

잘못될 수 있는 일을 **결함** 이라 부른다. 그리고 결함에 대처할 수 있는 시스템을 **내결함성 또는 탄력성**을 지녔다고 말한다. **결함 확률을 0으로 줄이는 것은 불가능이므로 결함으로 인해 장애가 발생하지 않도록 내결함성 구조를 설계하는 것이 가장 좋다.**

일반적으로 결함 예방을 넘어 내결함성을 갖기를 선호하지만 결함이 발생하면 되돌릴 수 없는 경우가 있다. 바로 보안 문제다.

### 하드웨어 결함

다음과 같은 문제로 하드웨어 결함이 발생할 수 있다.

- 인간의 실수
- 하드디스크의 평균 장애 시간(약 10 ~ 50년 → 10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다).

장애율을 줄이기 위한 방법으로는 다음과 같다.

- 하드웨어 구성 요소에 중복을 추가
- 디스크는 RAID 구성, 서버는 이중 전원 디바이스와 핫 스왑을 가능한 CPU 구축

→ 구성 요소 하나가 죽으면 중복된 구성 요소를 대신 사용하는 방식

하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 많은 장비를 사용하게 됐고, 이와 비례해 결함율도 증가했다. 따라서 하드웨어 중복성을 추가하는 시스템으로 점점 변화하고 있다.

### 소프트웨어 오류

다음과 같은 문제로 오류가 발생할 수 있다.

- 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
- 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애

소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다. 주의 깊게 생각하고, 테스트를 빈틈없이 하며 프로세스를 격리하고 지속적으로 모니터링과 분석을 할 수밖에 없다.

### 인적 오류

사람은 시스템을 설계하고 구축하며 운영한다. 최선을 다해도 사람은 미덥지 않다고 생각한다. 미덥지 않음에도 시스템을 어떻게 신뢰성 있게 만들까?

- 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라. 잘 설계된 추상화, API, 관리 인터페이스 등으로 잘못된 일을 막을 수 있다.
- 사람이 가장 많이 실수하는 부분에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라. 실제 사용자에게는 영향이 없는 비 프로덕션 샌드박스를 제공하라.
- 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라. 특히 코너 케이스를 주의 깊게 확인하라.
- 인적 오류를 빠르고 쉽게 복구할 수 있게 하라. 설정 변경 내역을 빠르게 롤백하고, 새로운 코드를 일부 유저에게만 영향이 미치게 하라.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.
- 조작 교육과 실습을 시행하라.

### 신뢰성은 얼마나 중요할까?

비즈니스 애플리케이션에서 버그는 생산성 저하의 원인이고, 전자 상거래 사이트의 중단은 매출에 손실이 발생하고 명성에 타격을 준다. 중요하지 않은 애플리케이션도 책임이 있다. 예를 들면 사진 애플리케이션에 아이들의 사진과 동영상을 보관한 부모가 사진과 동영상이 저장된 데이터베이스에 갑자기 오류가 생기면 어떨까?

시제품을 개발하는 비용이나 작은 이익의 서비스의 비용을 줄이려 신뢰성을 희생하는 경우가 있다. 이 경우에는 비용을 줄여야 하는 시점을 매우 잘 알고 있어야 한다.

## 확장성

성능 저하를 유발하는 이유 중 하나는 부하 증가다. 사용자 수가 1만 명에서 100만 명으로 증가함에 따라 시스템은 전에 처리했던 양보다 더 많은 데이터를 처리하고 있을지도 모른다.

확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어이다. 그러나 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?" 와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 같은 질문을 고려한다는 의미로 사용한다.

### 부하 기술하기

시스템의 현재 부하를 간결하게 기술해야 한다. 이는 부하 매개변수라 부르는데 시스템 설계에 따라 가장 적합한 매개변수를 선택해야 한다. 부하 매개변수로 다음과 같은 예제가 있다.

- 웹 서버의 초당 요청 수
- 데이터베이스의 읽기 대 쓰기 비율
- 대화방의 동시 활성 사용자
- 캐시 적중률

등이 있다. 또한 극단적인 소수의 경우도 생각해야 한다. 트위터로 예를 들어보자. 트위터는 원래 다음과 같이 홈 타임라인 피드를 구성했다.

1. 새로운 트윗은 전체 트윗을 모아 놓은 테이블에 삽입한다. 사용자가 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고 그 사람의 트윗을 시간순으로 정렬해서 합친다.

```sql
SELECT tweets.*, users.* from tweets
JOIN users ON tweets.sender_id = users.id
JOIN follows ON follows.followee_id = users.id
WHERE follows.follower_id = current_user 
```

1. 사용자가 트윗을 작성하면 사용자를 팔로우하는 사람의 홈 타임라인 캐시에 새로운 트윗을 삽입한다.

트위터는 원래 처음 방식을 사용했으나 시스템이 홈 타임라인의 부하를 버티기 위해 고군분투해야 했고, 그 결과 두 번째 접근 방식으로 전환했다. 하지만 팔로워가 3천만이 넘는 일부 사용자의 경우는 2번 방식을 사용할 경우 홈 타임라인에 3천만 건 이상의 쓰기 요청이 될지도 모르기 때문에 1번 방식이 적합하다.

이러한 예제로 생각해보면 부하를 측정할 때는 소수의 극단적인 예를 생각해야 한다.

### 성능 기술하기

일단 부하 매개변수를 설정하면 다음 두 가지 방법으로 성능을 측정하며 지표화 할 수 있다.

- 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야할까?

두 질문 모두 성능 수치가 필요하다. 따라서 시스템 성능에 대해 살펴보자

- 처리랑(throughput) : 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합을 처리할 때 걸리는 전체 시간 (하둡과 같은 일괄처리 시스템에서 사용)
- 응답 시간(response time) :  클라이언트가 요청을 보내고 응답을 받는 사이의 시간

**응답 시간**은 매번 다르기 때문에 단일 숫자가 아닌 측정 가능한 값의 분포로 생각해야 한다. 사용자가 얼마나 오랫동안 기다려야 하는 지 알고 싶다면 중앙값(50분위, p50)이 좋은 지표이다. 중앙값은 응답 시간 목록의 중간 지점을 중앙값이라고 하며, 사용자의 반은 중앙값보다 빠르고, 나머지 반은 오래 걸린다는 뜻이다.

특이 값을 파악하기 위해서는 상위 백분위를 살펴보는 것도 좋다. 이때 사용하는 백분위는 95분위, 99분위, 99.9분위가 일반적이다. (p95, p99, p999) 

**꼬리 지연 시간(tail latency)**으로 알려진 상위 백분위 응답 시간은 사용자 경험의 직접적인 영향을 주기 때문에 중요하다. 예를 들어 아마존은 내부 응답 시간의 요구 사항을 p999로 표현한다. 이는 요청 1,000개 중에 가장 느린 응답 속도 하나를 나타내는 숫자이다.

보통 응답 시간이 느린 고객일 경우 많은 구입을 통해 데이터를 많이 갖고 있어 가장 소중한 고객이다. 따라서 빠른 서비스를 제공하여 이 고객을 행복하게 만드는 것이 중요하다.

반면 99.99분위를 최적화 하는 작업에는 비용이 많이 들어 아마존에서는 충분히 이익을 가져다 주지 못한다고 여겨진다.

p999를 최적화 하는 이유로는 **큐 대기 지연(queueing delay)** 가 있다. 서버는 병렬로 소수의 작업만 처리할 수 있기에 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체된다. 이를 **선두 차단(head-of-line blocking) 이라고 한다.** 

### 부하 대응 접근 방식

부하 매개변수가 어느 정도 증가하더라도 종은 성능을 유지하려면 어떻게 해야 할까? 사람들은 확장성과 관련해 두 가지로 분리하여 말한다.

- 용량 확장(scaling up)

    좀 더 강력한 장비로 이동

- 규모 확장(scaling out)

    다수의 낮은 사양 장비에 부하를 분산

고사양 장비는 매우 비싸 규모 확장이 효율적이다.

일부 시스템은 **탄력적(elastic)** 이다. 즉 부하 증가를 감지하면 자원을 자동으로 추가할 수 있다. 반면 그렇지 않은 시스템은 수동으로 확장해야 한다. 탄련적인 시스템은 부하를 예측할 수 없을 만큼 높을 경우 유용하지만 수동으로 확장하는 시스템이 더 간단하고 예상치 못한 일이 더 적다.

다수의 장비에 상태 비저장(stateless)  서비스를 배포하는 일은 쉬운 반면, 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 많은 복잡도가 발생한다. 이런 일로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.

최근에는 분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 일부 애플리케이션에는 바뀌었다.  대용량 데이터를 사용하지 않아도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성이 있다.

대개 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다. 범용적이고 모든 상황에 맞는 확장 아키텍처는 없다. 읽기, 쓰기 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등에 맞추어 아키텍처를 설계해야 한다.

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 이 가정은 곧 부하 매개변수가 된다.

## 유지 보수성

---

소프트웨어의 비용은 대부분 지속해서 이어지는 유지보수에 들어간다.

(버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기술 추가 등)

많은 사람들은 레거시 시스템을 유지 보수하는 것을 좋아하지 않는다. 하지만 희망적인 점은 유지보수 중 고통을 최소화 하고 레거시 소프트웨어를 직접 만들지 않게 끔 소프트웨어를 설계할 수 있다는 것이다. 그러기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세가지다.

- 운용성(operability)

    운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라.

- 단순성(simplicity)

    시스템에서 복잡도를 최대한 제거해 새로운 개발자가 시스템을 이해하기 쉽게 만들어라.

- 발전성(evolvability)

    개발자가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기 쉽다.

### 운용성: 운영의 편리함 만들기

좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미다. 즉 동일 반복 태스크를 쉽게 할 수 있도록 만들어야 한다.

### 단순성: 복잡도 관리

프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워진다. 복잡도는 다양한 증상으로 나타난다. 상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹,  임시방편으로 문제를 해결한 특수 사례 등이 이런 증상이다.

개발자가 시스템을 이해하고 추론하기 어려워지면 시스템에 숨겨진 가정과 의도치 않은 결과 및 예기치 않은 상호작용을 간과하기 쉽다. 따라서 시스템은 단순해야 한다.

복잡도를 제거하기 위한 최상의 도구는 추상화다. 이런 추상화를 통해 비슷한 기능을 여러 번 재구현 하는 것보다 더 효율적인 재사용이 가능하다.

### 발전성: 변화를 쉽게 만들기
